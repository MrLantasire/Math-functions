#include "vector.h"
#include "common.h"

/***********************************************************
* Функция сложения двух векторов в координатном виде.
* Входные данные:
* a - Первый вектор
* b - Второй вектор
* Выходные данные:
* Вектор a + b
************************************************************/
vector32_3D_t Vector_add(vector32_3D_t a, vector32_3D_t b)
{
    return (vector32_3D_t){(a.i + b.i), (a.j + b.j), (a.k + b.k)};
}

/***********************************************************
* Функция вычитания из вектора a вектора b в координатном виде.
* Входные данные:
* a - Первый вектор
* b - Второй вектор
* Выходные данные:
* Вектор a - b
************************************************************/
vector32_3D_t Vector_sub(vector32_3D_t a, vector32_3D_t b)
{
    return (vector32_3D_t){(a.i - b.i), (a.j - b.j), (a.k - b.k)};
}

/***********************************************************
* Функция умножения вектора на число в координатном виде.
* Входные данные:
* a - Вектор
* b - Скаляр
* Выходные данные:
* Вектор a * b
************************************************************/
vector32_3D_t Vector_mul(vector32_3D_t a, float b)
{
    return (vector32_3D_t) {(a.i * b), (a.j * b), (a.k * b)};
}

/***********************************************************
* Функция векторного произведения в координатном виде.
* Входные данные:
* a - Первый вектор
* b - Второй вектор
* Выходные данные:
* Вектор a X b
************************************************************/
vector32_3D_t Vector_cross_mul(vector32_3D_t a, vector32_3D_t b)
{
    vector32_3D_t out = {0};

    out.i = a.j * b.k - b.j * a.k;
    out.j = b.i * a.k - a.i * b.k;
    out.k = a.i * b.j - b.i * a.j;
    return out;
}

/***********************************************************
* Функция скалярного произведения векторов.
* Входные данные:
* a - Первый вектор
* b - Второй вектор
* Выходные данные:
* Скаляр a * b
************************************************************/
float Vector_scalar_mul(vector32_3D_t a, vector32_3D_t b)
{
    return (a.i * b.i + a.j * b.j + a.k * b.k);
}

/***********************************************************
* Функция смешанного произведения трех векторов.
* Входные данные:
* a - Первый вектор
* b - Второй вектор
* c - Третий вектор
* Выходные данные:
* Скаляр a * (b X c)
************************************************************/
float Vector_mixed_mul(vector32_3D_t a, vector32_3D_t b, vector32_3D_t c)
{
    float out = 0.0;

    out += a.i * b.j * c.k;
    out += c.i * a.j * b.k;
    out += b.i * c.j * a.k;
    out -= a.i * c.j * b.k;
    out -= b.i * a.j * c.k;
    out -= c.i * b.j * a.k;

    return out;
}

/***********************************************************
* Функция вычисления длины (нормы) вектора.
* Входные данные:
* a - Вектор
* Выходные данные:
* Скаляр |a| - длина ветора
************************************************************/
float Vector_abs(vector32_3D_t a)
{
    return (sqrt(a.i * a.i + a.j * a.j + a.k * a.k));
}

/***********************************************************
* Функция вычисления нормализованного вектора.
* Входные данные:
* a - Вектор
* Выходные данные:
* Вектор, у которого длина равна 1
************************************************************/
vector32_3D_t Vector_normalize(vector32_3D_t a)
{
    float vector_len = Vector_abs(a);

    if (ABS(vector_len) > 0.0)
    {
        a.i /= vector_len;
        a.j /= vector_len;
        a.k /= vector_len;
    }

    return a;
}

/***********************************************************
* Функция вычисления угла между векторами.
* Входные данные:
* a - Первый вектор
* b - Второй вектор
* Выходные данные:
* out - угол, [rad]
************************************************************/
float Define_angle_of_vectors(vector32_3D_t a, vector32_3D_t b)
{
    float out = Vector_abs(a) * Vector_abs(b);

    if (ABS(out) > 0.0)
    {
        out = Vector_scalar_mul(a,b) / out;

        if(ABS(out) > 1.0)
        {
            out /= ABS(out);
        }

        out = acos(out);
    }

    return out;
}

/***********************************************************
* Функция вычисления матрицы поворота вокруг любого вектора.
* Входные данные:
* n - Вектор, вокруг которго происходит вращение
* angle - Угол поворота [rad]
* Выходные данные:
* out_matrix - Указатель на массив матрицы поворота размером 3 * 3
************************************************************/
extern void Get_rotation_matrix(vector32_3D_t n, float angle, float *out_matrix)
{
    n = Vector_normalize(n);

    if(!(ABS(Vector_abs(n)) > 0.0))
    {
        angle = 0.0;
    }

    out_matrix[0] = n.i * n.i + cos(angle) * (1.0 - n.i * n.i);
    out_matrix[1] = n.i * n.j * (1.0 - cos(angle)) - n.k * sin(angle);
    out_matrix[2] = n.i * n.k * (1.0 - cos(angle)) + n.j * sin(angle);
    out_matrix[3] = n.j * n.i * (1.0 - cos(angle)) + n.k * sin(angle);
    out_matrix[4] = n.j * n.j + cos(angle) * (1.0 - n.j * n.j);
    out_matrix[5] = n.j * n.k * (1.0 - cos(angle)) - n.i * sin(angle);
    out_matrix[6] = n.k * n.i * (1.0 - cos(angle)) - n.j * sin(angle);
    out_matrix[7] = n.k * n.j * (1.0 - cos(angle)) + n.i * sin(angle);
    out_matrix[8] = n.k * n.k + cos(angle) * (1.0 - n.k * n.k);
}
